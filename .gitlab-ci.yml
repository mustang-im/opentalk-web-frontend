# SPDX-FileCopyrightText: OpenTalk GmbH <mail@opentalk.eu>
#
# SPDX-License-Identifier: EUPL-1.2

---
default:
  image: node:18-alpine

stages:
  - lint
  - test
  - build
  - deploy
  - cleanup

lint:prettier+eslint:
  stage: lint
  rules:
    - if: $CI_PIPELINE_SOURCE == 'merge_request_event'
  before_script:
    - apk add git
    - yarn install
  script:
    - yarn lint --no-inline-config --max-warnings 0
    - yarn workspaces foreach -pA run fmt:ci

lint:yaml:
  stage: lint
  image: archlinux:latest
  rules:
    - if: $CI_PIPELINE_SOURCE == 'merge_request_event'
  before_script:
    - pacman -Syy --noconfirm yamllint
  script: yamllint .

lint:compliance:
  stage: lint
  rules:
    - if: $CI_PIPELINE_SOURCE == 'merge_request_event'
  before_script:
    - apk add git
    - yarn install
  script:
    - yarn dlx licensee --production --errors-only

lint:licensing:
  stage: lint
  image:
    name: fsfe/reuse:latest
    entrypoint: ['']
  rules:
    - if: $CI_PIPELINE_SOURCE == 'merge_request_event'
  script:
    - reuse lint

lint:audit:
  stage: lint
  rules:
    - if: $CI_PIPELINE_SOURCE == 'merge_request_event'
  script:
    - yarn npm audit --environment production -RA
  allow_failure: true

test:build:
  stage: test
  rules:
    - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH
    - if: $CI_PIPELINE_SOURCE == 'merge_request_event'
    - if: $CI_COMMIT_TAG
  before_script:
    - apk add git
    - yarn install
  script:
    - yarn test
    - yarn build

build:container:
  stage: build
  image:
    name: gcr.io/kaniko-project/executor:debug
    entrypoint: ['']
  rules:
    # set variable for push to main
    - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH
      variables:
        IMAGE_DESTINATION_ARGS: --destination $CI_REGISTRY_IMAGE:latest
    # set variable for release tags
    - if: $CI_COMMIT_TAG
      variables:
        IMAGE_DESTINATION_ARGS: >
          --destination $CI_REGISTRY_IMAGE:latest
          --destination $CI_REGISTRY_IMAGE:$CI_COMMIT_TAG
    # set variable for MR event
    - if: $CI_PIPELINE_SOURCE == 'merge_request_event'
      variables:
        IMAGE_DESTINATION_ARGS: >
          --destination ${CI_REGISTRY_IMAGE}:${CI_MERGE_REQUEST_IID}_${CI_MERGE_REQUEST_SOURCE_BRANCH_NAME}
    # set variable for forked pipeline (commented out to get rid of pipelines in forked repos)
    # - if: $CI_PROJECT_ROOT_NAMESPACE != 'opentalk' &&
    #      $CI_COMMIT_BRANCH != $CI_DEFAULT_BRANCH &&
    #      $CI_COMMIT_BRANCH != null
    #  variables:
    #    IMAGE_DESTINATION_ARGS: --no-push
  script:
    - mkdir -p /kaniko/.docker
    - >
      echo
      "{\"auths\":{\"$CI_REGISTRY\":{\"auth\":\"$(echo -n ${CI_REGISTRY_USER}:${CI_REGISTRY_PASSWORD} | base64)\"}}}" >
      /kaniko/.docker/config.json
    - >
      /kaniko/executor
      --registry-mirror=mirror.gcr.io
      --context $CI_PROJECT_DIR
      --dockerfile $CI_PROJECT_DIR/ci/Dockerfile
      $IMAGE_DESTINATION_ARGS
      --force

build:container-profiling:
  stage: build
  image:
    name: gcr.io/kaniko-project/executor:debug
    entrypoint: ['']
  # todo - check when profiling should be build
  rules:
    - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH
    - if: $CI_COMMIT_TAG
  script:
    - mkdir -p /kaniko/.docker
    - >
      echo
      "{\"auths\":{\"$CI_REGISTRY\":{\"auth\":\"$(echo -n ${CI_REGISTRY_USER}:${CI_REGISTRY_PASSWORD} | base64)\"}}}" >
      /kaniko/.docker/config.json
    - >
      /kaniko/executor
      --registry-mirror=mirror.gcr.io
      --context $CI_PROJECT_DIR
      --dockerfile $CI_PROJECT_DIR/ci/Dockerfile
      --destination $CI_REGISTRY_IMAGE:${CI_COMMIT_TAG:+$CI_COMMIT_TAG-}profiling
      --destination $CI_REGISTRY_IMAGE:profiling
      --build-arg BUILD_TYPE="build:profiler"
      --force

publish:common:
  stage: deploy
  rules:
    - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH && $CI_PROJECT_ROOT_NAMESPACE == 'opentalk'
    - if: $CI_COMMIT_TAG != null
      changes:
        - packages/common/**/*
  before_script:
    - apk add git
    - yarn install
  script:
    - yarn build
    # If no .npmrc is included in the repo, generate a temporary one that is configured
    # to publish to GitLab's NPM registry
    - |
      if [[ ! -f .npmrc ]]; then
        echo 'No .npmrc found! Creating one now. Please review the following link for more information:
        https://docs.gitlab.com/ee/user/packages/npm_registry/index.html#project-level-npm-endpoint-1'
        {
          echo "@${CI_PROJECT_ROOT_NAMESPACE}:registry=${CI_API_V4_URL}/projects/434/packages/npm/"
          echo "${CI_API_V4_URL#http*:}/projects/434/packages/npm/:_authToken=\${CI_JOB_TOKEN}"
        } >> .npmrc
      fi
    - echo "Created the following .npmrc:"; cat .npmrc
    # Extract a few values from package.json
    - NPM_PACKAGE_NAME=$(node -p "require('./packages/common/package.json').name")
    - NPM_PACKAGE_VERSION=$(node -p "require('./packages/common/package.json').version")
    # Validate that the package name is properly scoped to the project's root namespace.
    # For more information, see https://docs.gitlab.com/ee/user/packages/npm_registry/#package-naming-convention
    - |
      if [[ ! $NPM_PACKAGE_NAME =~ ^@$CI_PROJECT_ROOT_NAMESPACE/ ]]; then
        echo "Invalid package scope! Packages must be scoped in the root namespace of the project,
        e.g. \"@${CI_PROJECT_ROOT_NAMESPACE}/${CI_PROJECT_NAME}\""
        echo 'For more information,
        see https://docs.gitlab.com/ee/user/packages/npm_registry/#package-naming-convention'
        exit 1
      fi
    # Compare the version in /common/package.json to all published versions.
    # If the package.json version has not yet been published, run `yarn publish:npm`.
    - |
      if [[ "$(npm view ${NPM_PACKAGE_NAME} versions)" != *"'${NPM_PACKAGE_VERSION}'"* ]]; then
        yarn publish:npm
        echo "Successfully published version ${NPM_PACKAGE_VERSION} of ${NPM_PACKAGE_NAME}
        to GitLab's NPM registry: ${CI_PROJECT_URL}/-/packages"
      else
        echo "Version ${NPM_PACKAGE_VERSION} of ${NPM_PACKAGE_NAME} has
        already been published, so no new version has been published."
      fi

deploy:review-app:
  stage: deploy
  rules:
    - if: $CI_PIPELINE_SOURCE == 'merge_request_event'
  image: alpine/helm:3.10.2
  tags:
    - kubernetes
  before_script:
    - helm repo add --username gitlab-ci-token --password ${CI_JOB_TOKEN}
      opentalk https://git.opentalk.dev/api/v4/projects/218/packages/helm/stable
  script:
    - helm upgrade --version 0.1.0 --install frontend-$CI_MERGE_REQUEST_IID opentalk/ot-web-frontend-helm
      --set image.repository=$CI_REGISTRY_IMAGE
      --set image.tag=${CI_MERGE_REQUEST_IID}_${CI_MERGE_REQUEST_SOURCE_BRANCH_NAME}
      --set ingress.tls[0].secretName=frontend-$CI_MERGE_REQUEST_IID-tls
      --set ot_frontend_url=www.$CI_MERGE_REQUEST_IID.review-latest.kube.opentalk.run
      --set ot_keycloak_domain=accounts.review-latest.kube.opentalk.run
      --set ot_backend_url=controller.review-latest.kube.opentalk.run
      --set-string 'ingress.annotations.nginx\.ingress\.kubernetes\.io/auth-type=basic'
      --set-string 'ingress.annotations.nginx\.ingress\.kubernetes\.io/auth-secret=web-frontend-basic-auth'
      --set-string 'ingress.annotations.nginx\.ingress\.kubernetes\.io/auth-realm=Authentication Required'
      -n review-latest --create-namespace
    - echo "https://${BASIC_AUTH_USER}:${BASIC_AUTH_PASS}@www.${CI_MERGE_REQUEST_IID}.review-latest.kube.opentalk.run"

cleanup:review-app:
  stage: cleanup
  rules:
    - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH &&
          $CI_PROJECT_ROOT_NAMESPACE == 'opentalk' &&
          $CI_PIPELINE_SOURCE == 'push'
  allow_failure: true
  image:
    name: alpine/helm:3.10.2
    entrypoint: ['']
  tags:
    - kubernetes
  script:
    - helm uninstall frontend-$CI_MERGE_REQUEST_IID -n review-latest

# todo delete specific container when MR is merged
# cleanup:container-image:
#  stage: cleanup
#  image: docker:dind
#  variables:
#    IMAGE_TAG: ${CI_MERGE_REQUEST_IID}_${CI_MERGE_REQUEST_SOURCE_BRANCH_NAME}
#  rules:
#    - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH &&
#           $CI_PROJECT_ROOT_NAMESPACE == 'opentalk' &&
#           $CI_PIPELINE_SOURCE == 'push'
#  allow_failure: true
#  before_script:
#    - apk add --update curl && rm -rf /var/cache/apk/*
#    - apk add jq
#  script:
#    - docker login -u $CI_REGISTRY_USER -p $CI_REGISTRY_PASSWORD $CI_REGISTRY
#    - docker rmi $CI_REGISTRY_IMAGE:${IMAGE_TAG} || true
#    - |
#      SCOPE="repository:${CI_REGISTRY_IMAGE}:delete"
#      echo $CI_REGISTRY_USER
#      echo $CI_REGISTRY_IMAGE
#      echo $CI_REGISTRY
#      echo $IMAGE_TAG
#      TOKEN=`curl --request GET --user "${CI_REGISTRY_USER}:${CI_JOB_TOKEN}" \
#              "${CI_SERVER_URL}/jwt/auth?service=container_registry&scope=${SCOPE}" | jq -r .token`
#
#      curl --request DELETE --header "Authorization: Bearer ${TOKEN}" \
#        --header "Accept: application/vnd.docker.distribution.manifest.v2+json" \
#        "https://${CI_REGISTRY}/v2/${CI_REGISTRY_IMAGE}/tags/reference/${IMAGE_TAG}"
#  services:
#    - docker:dind
