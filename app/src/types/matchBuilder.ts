// SPDX-FileCopyrightText: OpenTalk GmbH <mail@opentalk.eu>
//
// SPDX-License-Identifier: EUPL-1.2
import { Action, Actions, AnyAction, Dispatch } from '@reduxjs/toolkit';
import { Immutable } from 'immer';

interface TypedActionCreator<Type extends string> {
  (...args: never[]): Action<Type>;
  type: Type;
}

export type CaseResponder<S = never, A extends Action = AnyAction> = (state: Immutable<S>, action: A) => void;

export type CaseResponders<S, AS extends Actions> = {
  [T in keyof AS]: AS[T] extends Action ? CaseResponder<S, AS[T]> : void;
};

export interface MiddlewareMapBuilder<State> {
  /**
   * Adds a case responder to handle a single exact action type.
   * @remarks
   * This is similar to the builder from redux toolkit but does not reduce a state into a new one. This is meant for middleware that needs to distinguish many action types.
   * Responders (handler) will get an Immutable state passed to them when executed.
   * @param actionCreator - Either a plain action type string, or an action creator generated by [`createAction`](./createAction) that can be used to determine the action type.
   * @param handler - The actual case handler function.
   */
  addCase<ActionCreator extends TypedActionCreator<string>>(
    actionCreator: ActionCreator,
    handler: CaseResponder<State, ReturnType<ActionCreator>>
  ): MiddlewareMapBuilder<State>;

  /**
   * Adds a case responder to handle a single exact action type.
   * @remarks
   * This is similar to the builder from redux toolkit but does not reduce a state into a new one. This is meant for middleware that needs to distinguish many action types.
   * Responders (handler) will get an Immutable state passed to them when executed.
   * @param type - Either a plain action type string, or an action creator generated by [`createAction`](./createAction) that can be used to determine the action type.
   * @param handler - The actual case handler function.
   */
  addCase<Type extends string, A extends Action<Type>>(
    type: Type,
    handler: CaseResponder<State, A>
  ): MiddlewareMapBuilder<State>;

  /**
   * Adds a bundled case responder to handle a single exact action type.
   * @remarks
   * This is meant to bundle a lot of addCase clauses inside the outgoing definitions files.
   */
  addModule(builderCallback: (builder: MiddlewareMapBuilder<State>) => void): MiddlewareMapBuilder<State>;
}

export function matchBuilder<S>(
  builderCallback: (builder: MiddlewareMapBuilder<S>) => void
): CaseResponders<S, Actions<string>> {
  const actionsMap: CaseResponders<S, Actions<string>> = {};
  const builder = {
    addCase(typeOrActionCreator: string | TypedActionCreator<never>, reducer: CaseResponder<S>) {
      const type = typeof typeOrActionCreator === 'string' ? typeOrActionCreator : typeOrActionCreator.type;
      if (type in actionsMap) {
        throw new Error(`addCase cannot be called with two reducers for the same action type ${type}`);
      }
      actionsMap[type] = reducer;
      return builder;
    },
    addModule(builderCallback: (builder: MiddlewareMapBuilder<S>) => void) {
      builderCallback(builder);
      return builder;
    },
  };
  builderCallback(builder);
  return actionsMap;
}

export const createModule =
  <S>(inner: (builder: MiddlewareMapBuilder<S>, dispatch: Dispatch) => void) =>
  (matchBuilder: MiddlewareMapBuilder<S>, dispatch: Dispatch) => {
    inner(matchBuilder, dispatch);
  };
